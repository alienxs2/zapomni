{
  "id": "snapshot_1763843266012_6q6oxhl94",
  "approvalId": "approval_1763843266005_m9wdw5ccz",
  "approvalTitle": "Product Vision Document (product.md)",
  "version": 1,
  "timestamp": "2025-11-22T20:27:46.012Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Product Vision: Zapomni\n\n**Document Version**: 1.0\n**Created**: 2025-11-22\n**Authors**: Tony + Claude Code\n**Status**: Draft\n\n---\n\n## Executive Summary\n\n**Zapomni** is a next-generation local-first MCP (Model Context Protocol) memory system designed specifically for AI agents. It combines the knowledge graph intelligence of Cognee with the hybrid search capabilities of Claude Context, while running **100% locally** with zero external dependencies.\n\n**Core Value Proposition**: Zapomni provides AI agents with long-term, contextual memory through a unified vector + graph database architecture, enabling semantic search, relationship understanding, and code intelligence—all while guaranteeing complete data privacy and zero API costs.\n\n**Why Zapomni Exists**: Current solutions force a painful trade-off—cloud services like Cognee require API keys and leak data, while local tools like Claude Context lack knowledge graph capabilities. Zapomni eliminates this compromise by delivering enterprise-grade intelligence that runs entirely on your machine.\n\n**Key Achievement**: By leveraging FalkorDB's unified architecture (496x faster than alternatives) and Ollama's local LLM runtime, Zapomni achieves what was previously impossible: production-quality RAG with knowledge graphs, completely free and private.\n\n---\n\n## Vision & Mission\n\n### Vision\n\n**We envision a world where AI agents have perfect memory—private, intelligent, and truly theirs.**\n\nJust as humans build knowledge through connected experiences, AI agents should build understanding through interconnected information. Zapomni creates this reality by giving agents a \"second brain\" that:\n\n- Remembers everything they've learned, forever\n- Understands relationships between concepts, not just similarities\n- Respects privacy by never sending data to external servers\n- Costs nothing to run, enabling unlimited memory growth\n- Works offline, ensuring agents are never dependent on cloud services\n\nIn five years, we see Zapomni as the de facto memory layer for local AI systems—the foundation that transforms stateless agents into continuously learning partners.\n\n### Mission\n\n**Our mission: Democratize AI agent memory by making world-class knowledge graph technology accessible, private, and free.**\n\nWe achieve this by:\n\n1. **Building on open-source foundations**: FalkorDB, Ollama, MCP protocol\n2. **Prioritizing developer experience**: Simple setup, clear APIs, excellent documentation\n3. **Delivering production quality**: Performance, reliability, and accuracy from day one\n4. **Maintaining local-first principles**: Your data never leaves your machine, period\n5. **Fostering community**: Open development, transparent roadmap, welcoming contributions\n\n---\n\n## Problem Statement\n\n### Current Landscape\n\nThe AI agent ecosystem has exploded in 2024, with tools like Claude Desktop, Cursor, and Cline enabling powerful workflows. However, these agents face a fundamental limitation: **they lack persistent, contextual memory**.\n\n**Existing Solutions**:\n\n1. **Cognee** (Cloud-based knowledge graphs)\n   - Strengths: Mature, full-featured, production-ready\n   - Weaknesses: Requires OpenAI API keys ($), sends data to cloud, complex setup with separate databases\n\n2. **Claude Context** (Code search MCP)\n   - Strengths: 40% token reduction, hybrid BM25+vector search, simple deployment\n   - Weaknesses: Code-only focus, no knowledge graphs, no general document memory\n\n3. **PrivateGPT / LocalGPT** (Local RAG systems)\n   - Strengths: Private, flexible, good developer tools\n   - Weaknesses: No MCP integration, no knowledge graphs, manual integration required\n\n4. **LanceDB / ChromaDB** (Vector databases)\n   - Strengths: Fast vector search, local storage\n   - Weaknesses: Vector-only (no graph relationships), no MCP server built-in\n\n**Market Gap**: No solution combines MCP protocol, knowledge graphs, code intelligence, and 100% local operation in a unified architecture.\n\n### Pain Points\n\n#### 1. No True Local-First MCP Memory\n\n**The Problem**: Developers want privacy and zero costs, but existing MCP servers require cloud APIs.\n\n- Cognee needs OpenAI API key → $0.13 per 1M tokens (adds up fast)\n- Claude Context works locally but lacks knowledge graphs\n- Building custom MCP servers requires weeks of work\n\n**Impact**: Developers either sacrifice privacy (use cloud), sacrifice features (vector-only search), or sacrifice time (build from scratch).\n\n#### 2. Privacy Concerns with Cloud Services\n\n**The Problem**: Sending documents to OpenAI/Anthropic/Cohere for embeddings and entity extraction violates data privacy requirements.\n\n**Real-World Scenarios**:\n- Legal documents (attorney-client privilege)\n- Healthcare records (HIPAA compliance)\n- Corporate IP (trade secrets, NDAs)\n- Personal notes (journals, research)\n\n**Impact**:\n- Legal liability for organizations\n- Trust erosion for individuals\n- Regulatory non-compliance\n- Data breach risks\n\n#### 3. Cost of Cloud APIs\n\n**The Problem**: Embedding generation and LLM calls accumulate costs quickly.\n\n**Example Costs** (OpenAI pricing):\n- Embeddings: $0.13 per 1M tokens\n- GPT-4 completions: $10 per 1M tokens\n- For 10K documents (5M tokens): **$0.65 embeddings + $50 processing = $50.65**\n- Monthly for active use: **$100-500+**\n\n**Impact**: Makes AI memory prohibitively expensive for individuals, startups, and researchers.\n\n#### 4. Complexity of Separate Systems\n\n**The Problem**: Best practices require vector DB + graph DB + LLM + caching layer → operational nightmare.\n\n**Typical Stack**:\n- Vector DB: Qdrant/ChromaDB\n- Graph DB: Neo4j\n- LLM API: OpenAI\n- Cache: Redis\n- Orchestration: Custom code\n\n**Challenges**:\n- Keep systems in sync\n- Manage 4+ Docker containers\n- Handle connection pooling\n- Debug cross-system issues\n- Pay for multiple services\n\n**Impact**: High barrier to entry, slow development, increased maintenance burden.\n\n#### 5. Vector-Only Search Misses Context\n\n**The Problem**: Pure semantic similarity doesn't capture relationships.\n\n**Example**:\n- Query: \"How does Python relate to Django?\"\n- Vector search: Returns chunks mentioning both, but misses **relationship** (Django is built with Python)\n- Graph search: Traverses `Python -[USED_BY]-> Django` relationship\n\n**Impact**: Lower retrieval quality, missed insights, frustrated users.\n\n---\n\n## Solution Overview\n\n### What is Zapomni?\n\n**Zapomni is a local-first MCP memory server that gives AI agents intelligent, contextual, and private long-term memory.**\n\nIt combines:\n\n1. **Unified Vector + Graph Database** (FalkorDB)\n   - Vector embeddings for semantic search\n   - Property graph for relationships\n   - Single database, no synchronization\n\n2. **Local LLM Runtime** (Ollama)\n   - Embeddings: nomic-embed-text (81.2% accuracy, 2048 tokens)\n   - Entity extraction: Llama 3.1 / DeepSeek-R1 / Qwen2.5\n   - Zero external API calls\n\n3. **Hybrid Search Intelligence**\n   - BM25 keyword matching\n   - Vector semantic similarity\n   - Graph relationship traversal\n   - Cross-encoder reranking\n\n4. **MCP-Native Protocol**\n   - Stdio transport (simple, secure)\n   - Works with Claude CLI, Cursor, Cline\n   - Standard JSON-RPC 2.0 interface\n\n5. **Code-Aware Analysis**\n   - AST-based chunking (tree-sitter)\n   - Function and class extraction\n   - Call graph construction\n   - Multi-language support (29+ languages)\n\n### Key Differentiators\n\n#### 1. 100% Local & Free Forever\n\n**How it works**:\n- All processing on your machine (CPU or GPU)\n- Ollama runs LLMs locally (no API calls)\n- FalkorDB stores everything locally (no cloud sync)\n- Open-source codebase (Apache 2.0 license)\n\n**Benefits**:\n- Zero recurring costs (no API fees)\n- Complete data privacy (data never leaves machine)\n- Works offline (no internet required after setup)\n- No vendor lock-in (own your data)\n\n**Proof Point**: Research with 10K documents costs $50+ with cloud APIs, $0 with Zapomni.\n\n#### 2. Unified Vector + Graph Architecture\n\n**The Innovation**: FalkorDB combines both in one database.\n\n**Traditional Stack** (Cognee approach):\n```\nChromaDB (vector) ←sync→ Neo4j (graph)\n    ↓                      ↓\nEmbeddings           Entities/Relationships\n```\n\n**Zapomni Stack**:\n```\nFalkorDB (unified)\n    ↓\nVector + Graph in one system\n```\n\n**Advantages**:\n- No synchronization complexity\n- Single connection pool\n- Faster queries (no cross-DB joins)\n- Lower operational overhead\n- 496x faster P99 latency vs alternatives\n- 6x better memory efficiency\n\n#### 3. Knowledge Graph Intelligence\n\n**What it does**: Automatically extracts entities and relationships from text.\n\n**Example Workflow**:\n```\nInput: \"Python is a programming language created by Guido van Rossum in 1991.\"\n\nEntities Extracted:\n- Python (TECHNOLOGY)\n- Guido van Rossum (PERSON)\n- 1991 (DATE)\n- programming language (CONCEPT)\n\nRelationships:\n- Python -[CREATED_BY]-> Guido van Rossum\n- Python -[IS_A]-> programming language\n- Python -[CREATED_IN]-> 1991\n```\n\n**Benefits**:\n- Context-aware retrieval (not just keyword matching)\n- Discover connections (find all technologies created by person X)\n- Multi-hop reasoning (Python uses Django uses PostgreSQL)\n- Better answers (LLM gets graph context)\n\n#### 4. Code-Aware Intelligence\n\n**The Problem**: Naive chunking breaks code structure.\n\n**Example of Bad Chunking**:\n```python\n# Chunk 1 (incomplete):\ndef calculate_total(items):\n    total = 0\n    for item in items:\n        total += item.price\n    # CUT HERE - function split!\n\n# Chunk 2 (missing context):\n    return total\n```\n\n**Zapomni's AST-Based Chunking**:\n```python\n# Chunk 1 (complete function):\ndef calculate_total(items):\n    \"\"\"Calculate total price of items\"\"\"\n    total = 0\n    for item in items:\n        total += item.price\n    return total\n# COMPLETE SEMANTIC UNIT\n\n# Chunk 2 (separate function):\ndef apply_discount(total, discount):\n    \"\"\"Apply discount to total\"\"\"\n    return total * (1 - discount)\n```\n\n**Benefits**:\n- Preserves code structure (functions, classes)\n- Better code search (4.3 point accuracy gain)\n- Call graph construction (who calls what)\n- Multi-language support (Python, JS, Go, Rust, etc.)\n\n#### 5. MCP-Native Protocol\n\n**What is MCP?**: Model Context Protocol—Anthropic's standard for AI agent tool integration.\n\n**Why MCP Matters**:\n- Universal compatibility (works with any MCP client)\n- Standardized interface (tools, resources, prompts)\n- Security by default (stdio process isolation)\n- Simple debugging (all messages visible)\n\n**Integration Example**:\n```json\n// claude_desktop_config.json\n{\n  \"mcpServers\": {\n    \"zapomni\": {\n      \"command\": \"python\",\n      \"args\": [\"/path/to/zapomni-mcp/server.py\"],\n      \"env\": {\n        \"FALKORDB_HOST\": \"localhost\",\n        \"OLLAMA_HOST\": \"http://localhost:11434\"\n      }\n    }\n  }\n}\n```\n\n**Result**: Claude can now `add_memory()`, `search_memory()`, `build_graph()` seamlessly.\n\n### How It Works (High-Level)\n\n**User Workflow**:\n\n1. **Setup** (one-time, 30 minutes)\n   ```bash\n   # Install dependencies\n   docker run -p 6379:6379 falkordb/falkordb  # FalkorDB\n   curl -fsSL https://ollama.com/install.sh | sh  # Ollama\n   ollama pull nomic-embed-text  # Embedding model\n   pip install zapomni-mcp  # Zapomni\n\n   # Configure Claude\n   # Add to claude_desktop_config.json\n   ```\n\n2. **Add Documents** (via AI agent)\n   ```\n   User: \"Remember this research paper on knowledge graphs\"\n   Claude: [Calls add_memory tool]\n   Zapomni:\n     → Chunks document (semantic, 256-512 tokens)\n     → Generates embeddings (local Ollama)\n     → Stores in FalkorDB (vector + graph)\n     → Returns confirmation\n   ```\n\n3. **Search & Retrieve** (via AI agent)\n   ```\n   User: \"What did I learn about knowledge graphs?\"\n   Claude: [Calls search_memory tool]\n   Zapomni:\n     → Hybrid search (BM25 + vector + graph)\n     → Reranks results (cross-encoder)\n     → Returns top relevant chunks\n   Claude: [Generates answer from context]\n   ```\n\n4. **Build Knowledge Graph** (optional, async)\n   ```\n   User: \"Build a knowledge graph from my documents\"\n   Claude: [Calls build_graph tool]\n   Zapomni:\n     → Starts background task\n     → Extracts entities (SpaCy + Ollama)\n     → Detects relationships (LLM-based)\n     → Constructs graph (Cypher queries)\n     → Returns task ID\n   User can check: get status (graph_status tool)\n   ```\n\n**Technical Flow**:\n```\nDocument Input\n    ↓\n[Chunking] Semantic chunks (256-512 tokens, 10-20% overlap)\n    ↓\n[Embedding] nomic-embed-text via Ollama (768 dim vectors)\n    ↓\n[Storage] FalkorDB (vector index + metadata)\n    ↓\n[Optional] Entity Extraction → Knowledge Graph\n    ↓\n[Query] Hybrid search (BM25 + vector + graph)\n    ↓\n[Rerank] Cross-encoder top-K refinement\n    ↓\nResults to AI Agent\n```\n\n---\n\n## Target Audience\n\n### Primary Users\n\n#### 1. AI Engineers & Developers\n\n**Persona**: \"Alex, AI Engineer at Startup\"\n- Age: 25-40\n- Skills: Python/TypeScript, LLM experience, Docker comfortable\n- Tools: Claude CLI, Cursor, VS Code, GitHub Copilot\n- Pain: Building AI agents with memory is too hard and expensive\n\n**Needs**:\n- Easy-to-integrate memory layer for AI projects\n- Privacy-compliant solution (no cloud data leaks)\n- Fast iteration (no waiting for API calls)\n- Cost-effective (startup budget constraints)\n- Production-quality performance\n\n**Value from Zapomni**:\n- Drop-in MCP server (works with existing tools)\n- Zero API costs (save $100-500/month per project)\n- Fast local development (no network latency)\n- Knowledge graph for better retrieval\n- Open-source (can customize and contribute)\n\n**User Story**:\n> \"I'm building a coding assistant for my startup. Zapomni gives me production-quality RAG without monthly API bills, and the knowledge graph helps my agent understand code relationships—not just find similar snippets.\"\n\n#### 2. Privacy-Conscious Researchers\n\n**Persona**: \"Dr. Sarah, Academic Researcher\"\n- Age: 30-50\n- Field: Computer science, biology, law, social sciences\n- Pain: Can't use cloud AI tools with sensitive research data\n- Needs: Private document analysis, local LLM integration\n\n**Needs**:\n- Complete data privacy (HIPAA, IRB compliance)\n- No internet dependency (lab environments)\n- Cost-free operation (research budgets)\n- Knowledge graph for literature review\n- Export/backup capabilities\n\n**Value from Zapomni**:\n- 100% local processing (no compliance issues)\n- Works offline (air-gapped environments)\n- Free forever (no grant money needed)\n- Relationship discovery (connect research findings)\n- Academic-friendly open-source\n\n**User Story**:\n> \"I analyze sensitive medical research papers. Zapomni lets me use AI assistance without violating patient privacy or spending grant money on API fees.\"\n\n#### 3. Power Users of Claude/Cursor/Cline\n\n**Persona**: \"Jamie, Senior Developer\"\n- Age: 28-45\n- Setup: Claude Desktop + Cursor + 10+ MCP servers\n- Pain: Agents forget context between sessions\n- Needs: Long-term memory for AI coding assistants\n\n**Needs**:\n- Persistent memory across sessions\n- Code repository understanding\n- Fast retrieval (no workflow interruption)\n- Integration with existing MCP setup\n- Reliable and performant\n\n**Value from Zapomni**:\n- AI agent remembers past conversations\n- Code graph shows function dependencies\n- Sub-second search (doesn't slow down workflow)\n- Works with existing tools (Claude, Cursor)\n- Production-stable (no random failures)\n\n**User Story**:\n> \"My Claude agent now remembers every code decision I've made. When I ask 'Why did we choose FastAPI?', it finds the discussion from 3 weeks ago instantly.\"\n\n### Secondary Users\n\n#### 4. Technical Writers & Documentation Teams\n\n**Needs**: Semantic search across documentation, content deduplication, related content suggestions\n\n**Value**: Knowledge graph shows content relationships, hybrid search finds relevant docs\n\n#### 5. Legal Professionals\n\n**Needs**: Private document search, case law analysis, precedent discovery\n\n**Value**: Local processing (attorney-client privilege), relationship discovery (case citations)\n\n#### 6. Data Scientists & ML Engineers\n\n**Needs**: Experiment tracking, model documentation, research paper library\n\n**Value**: Code graph for model dependencies, semantic search for similar experiments\n\n---\n\n## Core Features by Phase\n\n### Phase 1: MVP (Weeks 1-2) - Essential Memory\n\n**Goal**: Basic local memory that works reliably\n\n**Scope**: 3 core MCP tools, vector search, local storage\n\n**Timeline**: 2 weeks\n\n#### Feature 1: add_memory(text, metadata)\n\n**User Story**:\n> As a developer, I want to save information to my agent's memory so that it can recall this information later in different conversations.\n\n**Functionality**:\n- Accept text input (up to 10MB per call)\n- Optional metadata (tags, source, date, custom fields)\n- Semantic chunking (256-512 tokens, 10-20% overlap)\n- Generate embeddings locally (Ollama/nomic-embed-text)\n- Store in FalkorDB (vector index + metadata)\n- Return memory ID and confirmation\n\n**Acceptance Criteria**:\n- [x] Can ingest 1000 documents in < 10 minutes\n- [x] Embeddings generated locally (no API calls)\n- [x] Data persisted to FalkorDB\n- [x] Returns unique memory ID\n- [x] Handles errors gracefully (invalid input, DB failures)\n- [x] Logs operation to stderr (MCP compliance)\n\n**Technical Specs**:\n- Chunk size: 256-512 tokens (configurable)\n- Overlap: 10-20% (50-100 tokens)\n- Embedding model: nomic-embed-text (768 dimensions)\n- Storage: FalkorDB Memory nodes with embedding property\n\n**Example Usage**:\n```json\n{\n  \"tool\": \"add_memory\",\n  \"arguments\": {\n    \"text\": \"RAG systems benefit from hybrid search combining BM25 and vector embeddings...\",\n    \"metadata\": {\n      \"tags\": [\"rag\", \"research\"],\n      \"source\": \"arxiv-2024-hybrid-search.pdf\",\n      \"date\": \"2024-11-20\"\n    }\n  }\n}\n\nResponse:\n{\n  \"status\": \"success\",\n  \"memory_id\": \"uuid-here\",\n  \"chunks_created\": 3,\n  \"text_preview\": \"RAG systems benefit from hybrid search...\"\n}\n```\n\n#### Feature 2: search_memory(query, limit, filters)\n\n**User Story**:\n> As an AI agent, I want to search the user's memory for relevant information based on a natural language query so that I can provide context-aware responses.\n\n**Functionality**:\n- Accept natural language query\n- Generate query embedding locally\n- Vector similarity search (cosine distance)\n- Metadata filtering (date range, tags, source)\n- Rank by relevance score\n- Return top K results with metadata\n\n**Acceptance Criteria**:\n- [x] Query latency < 500ms (P95)\n- [x] Semantic search (not just keyword matching)\n- [x] Supports metadata filters (tags, date, source)\n- [x] Returns similarity scores (0-1 range)\n- [x] Handles empty results gracefully\n- [x] No external API calls\n\n**Technical Specs**:\n- Search algorithm: Vector similarity (cosine)\n- Index type: HNSW (fast approximate)\n- Default limit: 10 results\n- Min similarity threshold: 0.5 (configurable)\n\n**Example Usage**:\n```json\n{\n  \"tool\": \"search_memory\",\n  \"arguments\": {\n    \"query\": \"What are best practices for RAG chunking?\",\n    \"limit\": 5,\n    \"filters\": {\n      \"tags\": [\"rag\"],\n      \"date_from\": \"2024-01-01\"\n    }\n  }\n}\n\nResponse:\n{\n  \"status\": \"success\",\n  \"count\": 5,\n  \"results\": [\n    {\n      \"memory_id\": \"uuid\",\n      \"text\": \"Semantic chunking with 256-512 tokens works best...\",\n      \"similarity_score\": 0.87,\n      \"tags\": [\"rag\", \"chunking\"],\n      \"source\": \"research.pdf\",\n      \"timestamp\": \"2024-11-20T10:30:00Z\"\n    },\n    ...\n  ]\n}\n```\n\n#### Feature 3: get_stats()\n\n**User Story**:\n> As a developer, I want to see statistics about my memory system so that I can monitor its health and usage.\n\n**Functionality**:\n- Count total memories stored\n- Count total chunks\n- Calculate database size\n- Show cache hit rate (if caching enabled)\n- Report average query latency\n\n**Acceptance Criteria**:\n- [x] Returns accurate counts\n- [x] Shows database size in MB\n- [x] Executes in < 100ms\n- [x] No parameters required\n- [x] Clear, structured output\n\n**Example Usage**:\n```json\n{\n  \"tool\": \"get_stats\"\n}\n\nResponse:\n{\n  \"status\": \"success\",\n  \"statistics\": {\n    \"total_memories\": 1542,\n    \"total_chunks\": 4821,\n    \"database_size_mb\": 234.5,\n    \"graph_name\": \"zapomni_memory\",\n    \"cache_hit_rate\": 0.64,\n    \"avg_query_latency_ms\": 187\n  }\n}\n```\n\n**Success Criteria for Phase 1**:\n\n- [x] All 3 tools working reliably\n- [x] Can ingest 1K documents in < 10 min\n- [x] Search < 500ms response time\n- [x] 100% offline operation (no API calls)\n- [x] Works with Claude CLI/Desktop\n- [x] Zero critical bugs\n- [x] Basic documentation (README + setup guide)\n- [x] 3+ beta testers provide positive feedback\n\n---\n\n### Phase 2: Enhanced Intelligence (Weeks 3-4)\n\n**Goal**: Hybrid search and semantic caching for better retrieval\n\n**Scope**: BM25 + vector fusion, cross-encoder reranking, semantic cache\n\n**Timeline**: 2 weeks\n\n#### Feature 4: Hybrid Search (BM25 + Vector)\n\n**Enhancement to search_memory()**:\n- Add BM25 keyword search in parallel\n- Fuse rankings with Reciprocal Rank Fusion (RRF)\n- Rerank top-20 with cross-encoder\n- Return top-K final results\n\n**Benefits**:\n- 3.4x better accuracy vs vector-only (research benchmark)\n- Handles exact terminology matches\n- Better for acronyms, names, technical terms\n\n**Acceptance Criteria**:\n- [x] Hybrid search 2-3x more accurate (measured on eval set)\n- [x] Query latency < 500ms (including reranking)\n- [x] Configurable fusion weights (alpha parameter)\n\n#### Feature 5: Semantic Caching\n\n**What it does**: Cache embeddings to reduce computation\n\n**Functionality**:\n- Exact match cache (SHA256 hash → embedding)\n- Semantic cache (find similar queries, reuse embeddings)\n- LRU eviction policy\n- Configurable TTL (default 24h)\n\n**Benefits**:\n- 60-68% cache hit rate (research target)\n- 20%+ latency reduction\n- Lower CPU/GPU usage\n\n**Acceptance Criteria**:\n- [x] Cache hit rate > 60% after warm-up\n- [x] Cached queries < 50ms vs 200ms+ uncached\n- [x] Automatic cache invalidation on data updates\n\n#### Feature 6: Cross-Encoder Reranking\n\n**What it does**: Refine top results with more accurate model\n\n**Functionality**:\n- Initial retrieval: Top 50 candidates (fast)\n- Reranking: Cross-encoder scores top 20 (accurate)\n- Return: Best 10 after reranking\n\n**Benefits**:\n- Significant precision improvement\n- Catches relevant results ranked low by initial retrieval\n\n**Acceptance Criteria**:\n- [x] Reranking improves top-10 precision by 15%+\n- [x] Adds < 200ms to query latency\n\n**Success Criteria for Phase 2**:\n\n- [x] Hybrid search deployed and accurate\n- [x] Cache hit rate > 60%\n- [x] Query latency maintained < 500ms\n- [x] 1K+ documents indexed\n- [x] Measurable quality improvement (eval metrics)\n\n---\n\n### Phase 3: Knowledge Graph (Weeks 5-6)\n\n**Goal**: Contextual understanding via entity and relationship extraction\n\n**Scope**: Entity extraction, relationship detection, graph queries\n\n**Timeline**: 2 weeks\n\n#### Feature 7: build_graph(memory_ids, mode)\n\n**User Story**:\n> As a user, I want Zapomni to automatically extract entities and relationships from my documents so that I can discover connections and get context-aware search results.\n\n**Functionality** (async background task):\n- Extract entities (hybrid SpaCy + Ollama)\n- Detect relationships (LLM-based)\n- Build graph in FalkorDB (nodes + edges)\n- Track progress (percentage updates)\n- Return task ID immediately\n\n**Acceptance Criteria**:\n- [x] Entity extraction precision > 80%\n- [x] Relationship detection precision > 70%\n- [x] Processes 1K documents in < 10 minutes\n- [x] Background task doesn't block main server\n- [x] Progress queryable via graph_status()\n\n**Example Usage**:\n```json\n{\n  \"tool\": \"build_graph\",\n  \"arguments\": {\n    \"memory_ids\": null,  // Process all unprocessed\n    \"mode\": \"full\"  // entities + relationships\n  }\n}\n\nResponse:\n{\n  \"status\": \"accepted\",\n  \"task_id\": \"uuid-task-id\",\n  \"message\": \"Graph building started in background\",\n  \"estimated_time_seconds\": 120\n}\n```\n\n#### Feature 8: get_related(entity, depth, limit)\n\n**User Story**:\n> As an AI agent, I want to find information related to a specific entity by traversing the knowledge graph so that I can provide contextually rich answers.\n\n**Functionality**:\n- Graph traversal from entity node\n- Follow RELATED_TO, MENTIONS edges\n- Configurable depth (1-3 hops)\n- Return related entities + relevant chunks\n\n**Acceptance Criteria**:\n- [x] Graph queries < 200ms\n- [x] Returns related entities with relationship types\n- [x] Includes strength scores for relationships\n\n**Example Usage**:\n```json\n{\n  \"tool\": \"get_related\",\n  \"arguments\": {\n    \"entity\": \"Python\",\n    \"depth\": 2,\n    \"limit\": 20\n  }\n}\n\nResponse:\n{\n  \"status\": \"success\",\n  \"source_entity\": \"Python\",\n  \"related_entities\": [\n    {\n      \"name\": \"Django\",\n      \"type\": \"TECHNOLOGY\",\n      \"relationship\": \"USES\",\n      \"strength\": 0.9,\n      \"distance\": 1\n    },\n    {\n      \"name\": \"Guido van Rossum\",\n      \"type\": \"PERSON\",\n      \"relationship\": \"CREATED_BY\",\n      \"strength\": 1.0,\n      \"distance\": 1\n    }\n  ],\n  \"related_memories\": [...]\n}\n```\n\n#### Feature 9: graph_status(task_id)\n\n**Functionality**: Check progress of background graph tasks\n\n**Acceptance Criteria**:\n- [x] Returns real-time progress percentage\n- [x] Shows task status (pending/running/completed/failed)\n- [x] Includes error messages if failed\n\n**Success Criteria for Phase 3**:\n\n- [x] Knowledge graph operational\n- [x] Entity extraction accuracy > 80%\n- [x] Relationship accuracy > 70%\n- [x] Graph queries fast (< 200ms)\n- [x] Hybrid search uses graph context\n- [x] Demonstrable improvement in answer quality\n\n---\n\n### Phase 4: Code Intelligence (Weeks 7-8)\n\n**Goal**: Deep code repository understanding\n\n**Scope**: AST-based chunking, call graphs, multi-language support\n\n**Timeline**: 2 weeks\n\n#### Feature 10: index_codebase(path, exclusions, language)\n\n**User Story**:\n> As a developer, I want Zapomni to index my code repository with understanding of code structure so that I can search for functions, classes, and understand dependencies.\n\n**Functionality** (async background task):\n- Scan repository recursively\n- Detect programming language per file\n- Parse AST with tree-sitter\n- Extract functions, classes, imports\n- Create code-specific chunks (preserve structure)\n- Build code graph (CALLS, INHERITS edges)\n\n**Acceptance Criteria**:\n- [x] Can index 1K files in < 15 minutes\n- [x] Preserves complete semantic units (functions, classes)\n- [x] Extracts metadata (signatures, docstrings)\n- [x] Builds call graph relationships\n- [x] Supports Python, JavaScript, TypeScript, Go, Rust\n\n**Technical Advantage**: AST-based chunking improves retrieval by 4.3 points vs naive splitting (research benchmark)\n\n**Example Usage**:\n```json\n{\n  \"tool\": \"index_codebase\",\n  \"arguments\": {\n    \"path\": \"/path/to/repo\",\n    \"exclusions\": [\"node_modules\", \"*.test.js\", \"__pycache__\"],\n    \"language\": \"auto\"\n  }\n}\n\nResponse:\n{\n  \"status\": \"accepted\",\n  \"task_id\": \"uuid-task-id\",\n  \"message\": \"Code indexing started in background\",\n  \"files_queued\": 342\n}\n```\n\n**Success Criteria for Phase 4**:\n\n- [x] Code indexing works for 5+ languages\n- [x] AST chunking preserves structure\n- [x] Code search 4.3 points better than naive\n- [x] Call graphs accurately constructed\n- [x] < 15 min to index 1K files\n\n---\n\n### Future Phases (Post-MVP, Weeks 9+)\n\n**Phase 5: Multi-Modal Support**\n- PDF table extraction\n- Image OCR\n- Multi-modal embeddings\n\n**Phase 6: Export & Migration**\n- Graph export (JSON, GraphML, Cypher)\n- Backup/restore functionality\n- Import from other systems (Cognee, Obsidian, etc.)\n\n**Phase 7: Advanced Analytics**\n- Query performance dashboards\n- Memory usage optimization\n- Entity popularity tracking\n- Graph visualization data\n\n**Phase 8: Plugin Ecosystem**\n- Custom chunking strategies\n- Custom embedding models\n- Custom entity extractors\n- Community plugins repository\n\n---\n\n## Competitive Landscape\n\n### vs Cognee\n\n| Aspect | Cognee | Zapomni | Winner |\n|--------|--------|---------|--------|\n| **Deployment** | Cloud + Local | Local-only | **Zapomni** (privacy) |\n| **Cost** | API fees ($100-500/mo) | $0 | **Zapomni** (free) |\n| **Database** | Separate vector + graph | Unified (FalkorDB) | **Zapomni** (simpler) |\n| **Setup Complexity** | High (many components) | Medium (Docker + pip) | **Zapomni** (easier) |\n| **Performance (P99)** | Good | **496x faster** | **Zapomni** (FalkorDB) |\n| **Memory Efficiency** | Baseline | **6x better** | **Zapomni** (FalkorDB) |\n| **Tool Count** | 10+ tools | 6-10 tools (phased) | Cognee (features) |\n| **Maturity** | Production-ready | MVP → Production | Cognee (stability) |\n| **Community** | Active | New | Cognee (support) |\n| **Language** | Python | Python | Tie |\n| **License** | Apache 2.0 | Apache 2.0 | Tie |\n| **Privacy** | Cloud option | **Local-only** | **Zapomni** (guaranteed) |\n\n**Zapomni Advantages**:\n1. ✅ **100% local, zero API costs** - Save $100-500/month\n2. ✅ **Unified database** - Simpler architecture, easier maintenance\n3. ✅ **496x better performance** - FalkorDB's GraphBLAS backend\n4. ✅ **6x better memory efficiency** - Lower resource usage\n5. ✅ **Privacy guarantee** - Data never leaves machine\n\n**Cognee Advantages**:\n1. ✅ **More mature** - Battle-tested in production\n2. ✅ **More features** - 10+ tools, advanced search types\n3. ✅ **Larger community** - More users, more support\n4. ✅ **Cloud option** - For teams needing managed service\n\n**When to choose Zapomni**: Privacy requirements, cost constraints, local-first philosophy, simpler architecture preferred\n\n**When to choose Cognee**: Need cloud deployment, want more features immediately, prefer mature solution\n\n### vs Claude Context\n\n| Aspect | Claude Context | Zapomni | Winner |\n|--------|----------------|---------|--------|\n| **Focus** | Code search only | General memory + code | **Zapomni** (versatile) |\n| **Language** | TypeScript | Python | Preference |\n| **Knowledge Graph** | ❌ No | ✅ Yes | **Zapomni** (context) |\n| **Vector DB** | Milvus | FalkorDB (vector+graph) | **Zapomni** (unified) |\n| **Graph DB** | ❌ No | ✅ FalkorDB | **Zapomni** (relationships) |\n| **LLM** | OpenAI API (cloud) | Ollama (local) | **Zapomni** (privacy) |\n| **Hybrid Search** | ✅ BM25 + vector | ✅ BM25 + vector + graph | **Zapomni** (graph boost) |\n| **Token Reduction** | 40% | TBD (likely similar) | Claude Context (proven) |\n| **Setup** | Easy (npx) | Medium (Docker + pip) | Claude Context (faster) |\n| **Privacy** | Local option | **Local-only** | **Zapomni** (guaranteed) |\n| **Code Chunks** | Simple splitting | **AST-based** | **Zapomni** (structural) |\n| **General Docs** | ❌ No | ✅ Yes | **Zapomni** (versatile) |\n\n**Zapomni Advantages**:\n1. ✅ **General-purpose** - Documents + code (not just code)\n2. ✅ **Knowledge graph** - Understand relationships\n3. ✅ **100% local** - Privacy guaranteed, not optional\n4. ✅ **AST-based code chunking** - Better structure preservation\n5. ✅ **Unified architecture** - One database for everything\n\n**Claude Context Advantages**:\n1. ✅ **Simpler setup** - Single npx command\n2. ✅ **Proven token reduction** - 40% measured improvement\n3. ✅ **TypeScript** - If preferred over Python\n4. ✅ **Code-specialized** - Optimized for one use case\n\n**When to choose Zapomni**: Need general document memory, want knowledge graphs, prefer 100% local\n\n**When to choose Claude Context**: Only need code search, prefer TypeScript, want simplest setup\n\n### Unique Zapomni Position\n\n**Market Position**: The only solution combining MCP protocol, knowledge graphs, code intelligence, and 100% local operation in a unified architecture.\n\n**Competitive Moats**:\n\n1. **Unified Vector + Graph**: FalkorDB eliminates the complexity of maintaining separate databases while delivering superior performance (496x faster, 6x memory efficient)\n\n2. **Local-First by Design**: Not an option or addon—Zapomni is built from the ground up to never require external APIs\n\n3. **Knowledge Graph Intelligence**: Automatic entity and relationship extraction gives context that pure vector search can't provide\n\n4. **Code-Aware**: AST-based chunking and call graphs provide deep code understanding\n\n5. **MCP-Native**: First-class integration with the emerging MCP ecosystem (Claude, Cursor, Cline)\n\n**Why Competitors Can't Easily Replicate**:\n\n- **Cognee** would need to rewrite for local-only (business model conflict) and adopt unified DB (architectural redesign)\n- **Claude Context** would need to add general document support and knowledge graphs (scope expansion)\n- **PrivateGPT/LocalGPT** would need MCP integration and knowledge graphs (new capabilities)\n\n**Market Gap We Fill**:\n```\n         Cloud ←——————— Deployment ——————→ Local\n            │                               │\nCognee ────┤                               ├──── Zapomni\n            │                               │\nComplex ←── Features ————————————→ Simple  │\n            │                               │\n            │                               ├──── Claude Context\n         Full    ←── Scope ───→ Code-only\n```\n\nZapomni occupies the **\"Local + Full-featured + Privacy-first\"** quadrant that no one else does.\n\n---\n\n## Success Criteria & Metrics\n\n### MVP Success (End of Week 2)\n\n**Functional Criteria**:\n- [x] All 3 core tools working (add_memory, search_memory, get_stats)\n- [x] Can ingest 1000 documents in < 10 minutes\n- [x] Search returns relevant results in < 500ms (P95)\n- [x] Works offline with 0 external API calls\n- [x] Integrates with Claude CLI successfully\n\n**Quality Criteria**:\n- [x] No critical bugs (crashes, data loss, corruption)\n- [x] Clear error messages for common issues\n- [x] Basic documentation exists (README, setup guide)\n- [x] Handles edge cases gracefully (empty input, very large docs)\n\n**User Validation**:\n- [x] 3+ beta testers successfully set up and use\n- [x] Positive feedback on core functionality\n- [x] At least one \"this solves my problem\" testimonial\n\n**Technical Metrics**:\n- Query latency: P50 < 200ms, P95 < 500ms, P99 < 1000ms\n- Ingestion speed: > 100 docs/minute\n- Memory usage: < 4GB RAM for 1K documents\n- Startup time: < 5 seconds to first query\n\n### Phase 2 Success (Week 4)\n\n**Functional Criteria**:\n- [x] Hybrid search 2-3x more accurate than vector-only\n- [x] Semantic cache operational with > 60% hit rate\n- [x] Cross-encoder reranking improves precision\n- [x] 1K+ documents indexed and searchable\n\n**Performance Metrics**:\n- Query latency: Still < 500ms with hybrid search + reranking\n- Cache hit rate: > 60% after warm-up period\n- Accuracy improvement: 2-3x measured on eval dataset\n\n### Phase 3 Success (Week 6)\n\n**Functional Criteria**:\n- [x] build_graph() extracts entities with > 80% precision\n- [x] Relationship detection with > 70% precision\n- [x] get_related() returns contextually relevant entities\n- [x] Graph queries enhance search results\n\n**Technical Metrics**:\n- Entity extraction: > 80% precision, > 75% recall\n- Relationship detection: > 70% precision, > 65% recall\n- Graph building speed: 1K docs in < 10 minutes\n- Graph query latency: < 200ms\n\n### Phase 4 Success (Week 8)\n\n**Functional Criteria**:\n- [x] index_codebase() works for Python, JavaScript, Go, Rust\n- [x] AST chunking preserves function/class structure\n- [x] Code search 4.3 points better than naive splitting\n- [x] Call graphs accurately constructed\n\n**Technical Metrics**:\n- Code indexing: 1K files in < 15 minutes\n- Code search accuracy: +4.3 points vs naive (measured)\n- Call graph precision: > 85%\n\n### Long-Term Success (6-12 Months)\n\n#### Adoption Metrics\n\n**Open Source**:\n- [ ] 100+ GitHub stars\n- [ ] 10+ active community contributors\n- [ ] 5+ merged external pull requests\n- [ ] Featured in Awesome MCP Servers list\n\n**Distribution**:\n- [ ] 1K+ PyPI downloads/month\n- [ ] 50+ active installations (telemetry opt-in)\n- [ ] 3+ blog posts/tutorials by community\n\n**Community**:\n- [ ] Active GitHub Discussions\n- [ ] 10+ real-world use case examples\n- [ ] Discord/Slack channel (if demand)\n\n#### Technical Excellence\n\n**Performance**:\n- [ ] 10K+ documents indexed in production use cases\n- [ ] Sub-second query performance at scale\n- [ ] Memory usage < 10GB for 100K documents\n\n**Quality**:\n- [ ] 90%+ test coverage\n- [ ] Zero critical bugs in 3+ months\n- [ ] < 1% support ticket rate\n\n**Features**:\n- [ ] All 10 planned MCP tools implemented\n- [ ] Code indexing for 10+ languages\n- [ ] Multi-modal support (PDF tables, images)\n\n#### Ecosystem Impact\n\n**Integration**:\n- [ ] Works with 3+ MCP clients (Claude, Cursor, Cline)\n- [ ] 5+ documented integration examples\n- [ ] Plugin system launched with 3+ plugins\n\n**Research & Development**:\n- [ ] Published performance benchmarks\n- [ ] Documented architecture patterns\n- [ ] Academic citations (if applicable)\n\n**Business Validation**:\n- [ ] 10+ companies using in production\n- [ ] 3+ case studies published\n- [ ] Sponsorship or grant funding (optional)\n\n---\n\n## Roadmap\n\n### Q1 2025 (Weeks 1-8): Foundation & Core Features\n\n**Week 1-2: MVP Launch**\n- [x] Core infrastructure setup\n- [x] 3 essential MCP tools (add, search, stats)\n- [x] FalkorDB + Ollama integration\n- [x] Basic vector search\n- [x] Documentation and setup guide\n\n**Week 3-4: Enhanced Intelligence**\n- [ ] Hybrid search (BM25 + vector)\n- [ ] Semantic caching layer\n- [ ] Cross-encoder reranking\n- [ ] Performance optimization\n\n**Week 5-6: Knowledge Graph**\n- [ ] Entity extraction (SpaCy + Ollama)\n- [ ] Relationship detection\n- [ ] Graph construction and queries\n- [ ] Background task processing\n\n**Week 7-8: Code Intelligence**\n- [ ] AST-based code chunking\n- [ ] Call graph construction\n- [ ] Multi-language support\n- [ ] Code-specific search\n\n### Q2 2025 (Months 2-4): Polish & Community\n\n**Month 2: Refinement**\n- [ ] Bug fixes and stability improvements\n- [ ] Performance profiling and optimization\n- [ ] Comprehensive testing (unit, integration, e2e)\n- [ ] Security audit\n\n**Month 3: Documentation & Examples**\n- [ ] Complete API reference\n- [ ] Architecture deep-dive docs\n- [ ] Video tutorials\n- [ ] Example projects (5+ use cases)\n- [ ] Troubleshooting guide\n\n**Month 4: Community Building**\n- [ ] Public GitHub repository launch\n- [ ] PyPI package release (v1.0)\n- [ ] Contribution guidelines\n- [ ] Community Discord/Slack\n- [ ] Blog post series (architecture, use cases)\n\n### Q3 2025+ (Months 5+): Advanced Features & Ecosystem\n\n**Advanced Features**:\n- [ ] Multi-modal support (images, tables)\n- [ ] Advanced analytics dashboard\n- [ ] Export/import capabilities\n- [ ] Migration tools (from Cognee, Obsidian, etc.)\n\n**Plugin Ecosystem**:\n- [ ] Plugin architecture design\n- [ ] Plugin marketplace\n- [ ] Community plugins (5+ contributed)\n- [ ] Plugin documentation\n\n**Performance & Scale**:\n- [ ] Support for 1M+ documents\n- [ ] Distributed deployment options\n- [ ] Advanced caching strategies\n- [ ] Query optimization\n\n**Integrations**:\n- [ ] Obsidian integration\n- [ ] Logseq integration\n- [ ] Notion export compatibility\n- [ ] Additional MCP clients\n\n---\n\n## Non-Goals (Out of Scope)\n\n### What We're NOT Building\n\n#### 1. Cloud Services or SaaS Offering\n\n**Not Included**:\n- ❌ Cloud-hosted Zapomni service\n- ❌ Multi-tenant architecture\n- ❌ Subscription pricing\n- ❌ Managed database hosting\n- ❌ Cloud sync features\n\n**Rationale**: Conflicts directly with our local-first mission and privacy-first values. Adding cloud would compromise our core differentiator.\n\n**Alternative**: Users who need cloud can self-host on their own servers.\n\n#### 2. Multi-User Collaboration\n\n**Not Included**:\n- ❌ Shared workspaces\n- ❌ Real-time collaboration\n- ❌ User authentication/authorization\n- ❌ Access control (RBAC)\n- ❌ Team management features\n\n**Rationale**: Zapomni is a single-user local tool. Multi-user adds enormous complexity (auth, sync, conflict resolution) and would delay MVP by months.\n\n**Alternative**: Users can share exported graphs or run separate instances.\n\n#### 3. Web UI or Desktop GUI Application\n\n**Not Included**:\n- ❌ Web dashboard\n- ❌ Electron desktop app\n- ❌ Visual graph browser\n- ❌ Interactive UI for configuration\n\n**Rationale**: Zapomni is an MCP server designed for AI agent integration, not direct human interaction. Building UIs would divert resources from core functionality.\n\n**Alternative**:\n- MCP clients (Claude Desktop) provide the UI\n- Future: Optional third-party visualization plugins\n\n#### 4. Mobile Applications\n\n**Not Included**:\n- ❌ iOS app\n- ❌ Android app\n- ❌ Mobile-optimized interface\n\n**Rationale**: Desktop-first design. Mobile adds platform-specific complexity and doesn't align with developer-focused audience.\n\n**Alternative**: Desktop tools can sync via file exports if needed.\n\n#### 5. Enterprise Features\n\n**Not Included**:\n- ❌ SSO (Single Sign-On)\n- ❌ SAML/OAuth integration\n- ❌ Audit logging for compliance\n- ❌ Role-based permissions\n- ❌ Service-level agreements (SLAs)\n- ❌ Dedicated support contracts\n\n**Rationale**: Zapomni is an open-source community project, not an enterprise product. These features require sales, support, and legal overhead.\n\n**Alternative**: Enterprise users can fork and add these features themselves.\n\n#### 6. Real-Time Streaming or Live Data\n\n**Not Included**:\n- ❌ Live data feeds\n- ❌ WebSocket streaming\n- ❌ Real-time index updates\n- ❌ Event-driven architectures\n\n**Rationale**: Batch processing is simpler, more reliable, and sufficient for document memory use cases.\n\n**Alternative**: Users can re-index periodically or on-demand.\n\n#### 7. Advanced Machine Learning Features (Initially)\n\n**Not Included (for MVP)**:\n- ❌ Custom model training\n- ❌ Fine-tuning on user data\n- ❌ Active learning loops\n- ❌ Reinforcement learning from feedback\n\n**Rationale**: These are research-grade features that would significantly increase complexity. Focus is on proven techniques that work reliably.\n\n**Future Possibility**: May add as optional advanced features post-v1.0.\n\n### Why These Boundaries Matter\n\n**Focus**: By clearly defining what we're NOT building, we can focus resources on what matters most—local-first, privacy-preserving, intelligent memory for AI agents.\n\n**Scope Control**: Every feature above would delay MVP by weeks or months. Saying \"no\" to these lets us ship value faster.\n\n**Positioning**: These non-goals reinforce our unique position: simple, local, open-source, agent-focused.\n\n**Community**: Clear boundaries help contributors understand the project's direction and propose aligned features.\n\n---\n\n## Values & Principles\n\n### Core Values\n\n#### 1. Privacy First\n**Principle**: Your data is yours. It never leaves your machine.\n\n**In Practice**:\n- Zero telemetry by default (opt-in only)\n- No external API calls during operation\n- No cloud dependencies\n- Transparent data flow (documented architecture)\n- User control over all data (clear, delete, export)\n\n**Why It Matters**: In an age of data breaches and surveillance, privacy is not negotiable.\n\n#### 2. Zero Cost Forever\n**Principle**: Zapomni will always be 100% free to use.\n\n**In Practice**:\n- No API fees (local models only)\n- No freemium upsells\n- No paid tiers\n- Open-source (Apache 2.0)\n- No venture capital (community-funded if needed)\n\n**Why It Matters**: AI tools should be accessible to everyone—students, researchers, startups, individuals—not just those with corporate budgets.\n\n#### 3. Simplicity\n**Principle**: Simple things should be simple, complex things should be possible.\n\n**In Practice**:\n- Easy installation (< 30 minutes from zero to working)\n- Sensible defaults (works out of the box)\n- Progressive complexity (simple for basics, powerful for advanced)\n- Clear documentation (no jargon, lots of examples)\n- Minimal configuration required\n\n**Why It Matters**: Complex tools gather dust. Simple tools get used.\n\n#### 4. Performance\n**Principle**: Fast is a feature. Every millisecond matters.\n\n**In Practice**:\n- Target: < 500ms query latency\n- Optimize from day one (not \"later\")\n- Measure everything (profiling, benchmarks)\n- Use efficient algorithms (HNSW, not brute-force)\n- Resource-conscious (< 4GB RAM for 10K docs)\n\n**Why It Matters**: Slow tools interrupt flow. Fast tools feel like magic.\n\n#### 5. Open Source\n**Principle**: Transparent, community-driven, freely available.\n\n**In Practice**:\n- Public roadmap (GitHub Projects)\n- Open development (public discussions)\n- Welcoming to contributors (clear guidelines)\n- Liberal license (Apache 2.0)\n- No hidden code or proprietary components\n\n**Why It Matters**: Trust is built through transparency. Longevity comes from community.\n\n### Design Principles\n\n#### 1. Local-First, Online-Enhanced\n- Core functionality works 100% offline\n- Optional features can use internet (e.g., fetch from URL)\n- Degrade gracefully when offline\n- Never require cloud for basic operations\n\n**Example**: Document ingestion works offline. Web scraping (future) is optional.\n\n#### 2. Modular & Extensible\n- Clean abstractions (database, LLM, embedder)\n- Pluggable components (swap FalkorDB for ChromaDB if needed)\n- Extension points (custom chunkers, extractors)\n- Plugin architecture (future)\n\n**Benefit**: Easy to customize, test, and maintain.\n\n#### 3. Performance from Day One\n- Don't defer optimization to \"later\"\n- Profile early and often\n- Choose efficient data structures upfront\n- Set performance budgets (latency, memory)\n\n**Anti-Pattern**: \"We'll optimize when it's slow\" → It's always slow.\n\n#### 4. Developer-Friendly, Not GUI-Focused\n- Target: Developers and power users\n- Interface: CLI and MCP tools\n- Documentation: Code examples, not videos\n- UX: Fast and powerful, not pretty\n\n**Rationale**: Focus resources on core features, not UI polish.\n\n#### 5. Test-Driven Quality\n- Write tests alongside code\n- Unit tests for logic\n- Integration tests for workflows\n- Property-based tests for edge cases\n- Target: 80%+ coverage before 1.0\n\n**Why**: Bugs caught early are 10x cheaper to fix.\n\n#### 6. Ship Fast, Iterate Based on Feedback\n- MVP in 2 weeks, not 2 months\n- Real user feedback > perfect code\n- Version everything, deprecate gracefully\n- Iterate quickly on pain points\n\n**Anti-Pattern**: Build in isolation for 6 months, ship to crickets.\n\n---\n\n## Go-to-Market Strategy\n\n### Launch Plan\n\n#### Week 1-2: Private Beta\n**Audience**: 5-10 hand-picked testers\n\n**Activities**:\n- Personal outreach to AI engineers\n- Invite to Discord/GitHub Discussions\n- One-on-one setup sessions\n- Collect detailed feedback\n\n**Success Metrics**:\n- All testers successfully install\n- 3+ provide detailed feedback\n- 2+ \"I'd use this daily\" responses\n\n#### Week 3-4: Public Announcement\n**Channels**:\n- Reddit: r/LocalLLaMA, r/AIProgramming, r/MachineLearning\n- Hacker News: \"Show HN: Zapomni - Local-first MCP Memory for AI Agents\"\n- Twitter/X: Thread explaining problem, solution, demo\n- Dev.to / Hashnode: Blog post announcement\n\n**Content**:\n- Problem statement (privacy + cost)\n- Demo video (< 2 minutes)\n- Quick start guide\n- Comparison table (vs Cognee, Claude Context)\n\n**Success Metrics**:\n- 100+ GitHub stars in first week\n- 500+ website visits\n- 20+ downloads\n- 5+ positive comments\n\n#### Week 5-6: Content & Education\n**Content Types**:\n1. **Blog Post**: \"Building a Knowledge Graph Memory System with FalkorDB and Ollama\"\n2. **Video Tutorial**: \"Setting up Zapomni in 5 minutes\"\n3. **Use Case**: \"How I Use Zapomni to Remember Code Decisions\"\n4. **Comparison**: \"Zapomni vs Cognee vs Claude Context: Detailed Benchmark\"\n\n**Channels**:\n- Dev.to, Medium, Hashnode\n- YouTube (short tutorials)\n- GitHub README and docs/\n\n**Success Metrics**:\n- 1K+ blog post views\n- 500+ video views\n- 10+ community discussions started\n\n#### Week 7-8: Official Release\n**Milestones**:\n- PyPI package published (v1.0)\n- Documentation site live\n- Example projects repository\n- Contribution guidelines\n- Roadmap published\n\n**Announcement**:\n- Product Hunt launch\n- Reddit follow-up posts\n- Newsletter announcements (partner with AI newsletters)\n- Hacker News \"Show HN: Zapomni 1.0 - Production-ready MCP Memory\"\n\n**Success Metrics**:\n- 500+ GitHub stars\n- 100+ PyPI downloads/week\n- 10+ community contributions\n- Featured in 1+ AI newsletter\n\n### Community Building\n\n#### GitHub Presence\n- **Discussions**: Enable for Q&A, ideas, showcase\n- **Issues**: Templates for bugs, features, questions\n- **Projects**: Public roadmap board\n- **Wiki**: Architecture docs, tutorials\n\n#### Communication Channels\n- **Primary**: GitHub Discussions (async, searchable)\n- **Real-time**: Discord server (if demand > 50 users)\n- **Updates**: GitHub Releases + RSS feed\n\n#### Contribution Flow\n1. **Onboarding**: CONTRIBUTING.md with clear steps\n2. **Good First Issues**: Tagged and documented\n3. **Recognition**: Contributors.md + GitHub badges\n4. **Reviews**: Fast, friendly, constructive feedback\n\n#### Community Events\n- **Monthly**: Community calls (Zoom/Discord)\n- **Quarterly**: Roadmap planning sessions\n- **Annually**: Zapomni Fest (virtual conference, if community grows)\n\n### Partnerships (Aspirational)\n\n#### MCP Ecosystem\n- **Anthropic**: Listed in official MCP servers directory\n- **MCP Community**: Cross-promotion with other servers\n\n#### Ollama Community\n- **Collaboration**: Optimize for Ollama performance\n- **Visibility**: Featured in Ollama examples\n\n#### Local AI Communities\n- **r/LocalLLaMA**: Regular updates, AMAs\n- **Local AI Discord servers**: Presence and support\n- **AI Tool Builders**: Collaborate with Cursor, Cline, etc.\n\n#### Academic Partnerships\n- **Universities**: Offer as research tool (privacy-friendly)\n- **Papers**: Cite in knowledge graph / RAG research\n- **Grants**: Apply for open-source grants (NLNet, Sovereign Tech Fund)\n\n---\n\n## Risks & Mitigation\n\n### Technical Risks\n\n#### Risk 1: FalkorDB Instability or Missing Features\n**Likelihood**: Medium\n**Impact**: High (blocks MVP)\n\n**Symptoms**:\n- Crashes during heavy load\n- Data corruption\n- Missing vector search features\n- Poor documentation\n\n**Mitigation**:\n1. **Prototype early** (Week 1): Thoroughly test FalkorDB before committing\n2. **Abstraction layer**: Design database interface to swap backends\n3. **Fallback plan**: Qdrant + Neo4j as alternative if FalkorDB fails\n4. **Community engagement**: Report bugs upstream, contribute fixes\n5. **Monitoring**: Health checks, automatic recovery\n\n**Contingency**: If FalkorDB problematic by Week 2, pivot to ChromaDB (vector) + Neo4j (graph).\n\n#### Risk 2: Ollama Model Quality Insufficient\n**Likelihood**: Low-Medium\n**Impact**: Medium (degraded UX)\n\n**Symptoms**:\n- Entity extraction misses obvious entities\n- Relationship detection hallucinates\n- Embeddings produce poor search results\n\n**Mitigation**:\n1. **Early benchmarking**: Test nomic-embed-text quality vs alternatives\n2. **Model flexibility**: Support multiple models (DeepSeek-R1, Qwen2.5)\n3. **Hybrid approach**: Combine NER (SpaCy) with LLM to reduce errors\n4. **Confidence filtering**: Only use high-confidence extractions (> 0.7)\n5. **Fallback**: sentence-transformers if Ollama embeddings fail\n\n**Contingency**: Switch to pure sentence-transformers if Ollama quality unacceptable.\n\n#### Risk 3: Poor Search Quality\n**Likelihood**: Medium\n**Impact**: High (core feature)\n\n**Symptoms**:\n- Irrelevant results in top 10\n- Relevant results buried deep\n- Hybrid search doesn't beat vector-only\n\n**Mitigation**:\n1. **Evaluation dataset**: Create ground truth query-document pairs\n2. **Metrics**: Track NDCG, MRR, Precision@K, Recall@K\n3. **Iterative tuning**: Adjust weights (BM25 vs vector), reranking\n4. **User feedback**: Relevance scoring mechanism\n5. **Multiple modes**: Offer vector-only, hybrid, graph as options\n\n**Contingency**: If hybrid underperforms, fall back to vector-only with metadata filtering.\n\n#### Risk 4: Performance Doesn't Scale\n**Likelihood**: Medium\n**Impact**: Medium (user frustration)\n\n**Symptoms**:\n- Queries slow down after 1K documents\n- Memory usage balloons to 10GB+\n- Ingestion takes hours\n\n**Mitigation**:\n1. **Early load testing**: Test with 1K, 5K, 10K documents in Weeks 2-4\n2. **Performance budgets**: Set targets (500ms, 4GB), monitor\n3. **Profiling**: cProfile, memory_profiler to find bottlenecks\n4. **Optimization**: HNSW indexing, batch processing, streaming\n5. **Partitioning**: Time-based or topic-based partitioning for large corpora\n\n**Contingency**: Simplify (remove graph, use simpler models) if performance unacceptable.\n\n### Product Risks\n\n#### Risk 5: Insufficient Differentiation\n**Likelihood**: Low-Medium\n**Impact**: High (no users)\n\n**Symptom**: \"Why not just use Cognee?\"\n\n**Mitigation**:\n1. **Clear positioning**: Local-first + unified DB + knowledge graph (unique combo)\n2. **Performance proof**: Publish benchmarks (496x faster)\n3. **Cost narrative**: \"$0 vs $100+/month\" is compelling\n4. **Privacy messaging**: Target privacy-conscious users first\n5. **Community**: Build loyal early adopters\n\n**Contingency**: Pivot messaging based on user feedback.\n\n#### Risk 6: Limited Adoption\n**Likelihood**: Medium\n**Impact**: Medium (small community)\n\n**Symptom**: < 50 GitHub stars after 3 months\n\n**Mitigation**:\n1. **Quality over quantity**: Focus on solving problem well for niche\n2. **Word of mouth**: Delight early users, they'll evangelize\n3. **Content marketing**: Tutorials, blog posts, videos\n4. **Partnerships**: Collaborate with MCP, Ollama communities\n5. **Patience**: Organic growth takes time (6-12 months)\n\n**Contingency**: Continue development based on small but passionate user base.\n\n### Market Risks\n\n#### Risk 7: Cognee Adds Local-First Mode\n**Likelihood**: Low\n**Impact**: Medium (stronger competitor)\n\n**Mitigation**:\n1. **Speed**: Ship fast, build community quickly\n2. **Unified DB**: Our architecture advantage (they'd need to rewrite)\n3. **Simplicity**: Stay simpler and easier to use\n4. **Open source**: Community ownership vs corporate control\n\n**Contingency**: Compete on simplicity, community, and unified architecture.\n\n#### Risk 8: MCP Ecosystem Stagnates\n**Likelihood**: Low\n**Impact**: Medium (less market)\n\n**Mitigation**:\n1. **Standalone value**: Zapomni useful even without MCP (API mode)\n2. **Multiple protocols**: Add HTTP API if needed\n3. **Direct integrations**: Integrate with Cursor, Cline directly if MCP fails\n\n**Contingency**: Pivot to REST API if MCP adoption disappoints.\n\n---\n\n## Appendix: User Stories (Detailed)\n\n### User Story 1: Research Paper Library\n\n**Persona**: Dr. Sarah, Computer Science Researcher\n\n**Scenario**:\nSarah has collected 200 research papers on knowledge graphs. She wants to:\n- Quickly find papers discussing specific techniques\n- Discover connections between papers\n- Remember key findings for her literature review\n\n**Workflow**:\n1. **Ingestion**:\n   ```\n   Sarah: \"Add these 200 PDFs to memory\"\n   Zapomni: Extracts text, chunks (512 tokens), embeds, stores\n   Result: 200 documents, ~5000 chunks indexed\n   ```\n\n2. **Search**:\n   ```\n   Sarah: \"What papers discuss graph neural networks for knowledge graph completion?\"\n   Zapomni: Hybrid search → Returns 10 most relevant papers with key passages\n   Sarah gets: Paper titles, authors, relevant paragraphs, similarity scores\n   ```\n\n3. **Knowledge Graph**:\n   ```\n   Sarah: \"Build knowledge graph\"\n   Zapomni: Extracts entities (algorithms, authors, concepts), relationships\n   Result: Can now query \"What algorithms did Nickel propose?\"\n   ```\n\n**Value Delivered**:\n- Saves hours of manual searching\n- Discovers hidden connections between papers\n- Privacy: No paper content sent to cloud\n- Cost: $0 vs $50+ for cloud RAG service\n\n**Acceptance Criteria**:\n- [x] Can ingest 200 PDFs in < 30 minutes\n- [x] Search finds correct papers (> 80% relevance)\n- [x] Graph shows author-technique relationships\n- [x] All data stays local\n\n---\n\n### User Story 2: Code Decision Tracking\n\n**Persona**: Jamie, Senior Software Engineer\n\n**Scenario**:\nJamie works on a large codebase with frequent architectural decisions. Wants to:\n- Remember why specific libraries were chosen\n- Track technical debt decisions\n- Onboard new team members faster\n\n**Workflow**:\n1. **Record Decisions**:\n   ```\n   Jamie: \"Remember: We chose FastAPI over Flask because of async support and OpenAPI auto-docs\"\n   Zapomni: Stores decision with timestamp, tags: [fastapi, architecture, web-framework]\n   ```\n\n2. **Code Indexing**:\n   ```\n   Jamie: \"Index our Python codebase\"\n   Zapomni: AST parsing → 500 functions, 80 classes → Call graph\n   Result: Understands code structure, dependencies\n   ```\n\n3. **Later Query**:\n   ```\n   New Developer: \"Why did we use FastAPI?\"\n   Claude (via Zapomni): \"You chose FastAPI for async support and OpenAPI auto-docs (decision from 2024-10-15)\"\n   ```\n\n4. **Code Search**:\n   ```\n   Jamie: \"Find functions that handle authentication\"\n   Zapomni: Searches code graph → Returns relevant functions with context\n   ```\n\n**Value Delivered**:\n- Institutional knowledge preserved\n- Faster onboarding (new devs find answers)\n- Better code navigation\n- Privacy: Company code never leaves network\n\n**Acceptance Criteria**:\n- [x] Records free-text decisions\n- [x] Indexes 500-file codebase in < 15 min\n- [x] Code search finds relevant functions\n- [x] Call graph shows dependencies\n\n---\n\n### User Story 3: Personal Knowledge Base\n\n**Persona**: Alex, Lifelong Learner\n\n**Scenario**:\nAlex takes notes while learning about AI, programming, and science. Wants to:\n- Build a personal Wikipedia\n- Connect ideas across domains\n- Never lose a note or insight\n\n**Workflow**:\n1. **Daily Learning**:\n   ```\n   Alex: \"Add note: Transformer architecture uses self-attention to process sequences in parallel\"\n   Zapomni: Stores note, extracts entities (Transformer, self-attention)\n   ```\n\n2. **Knowledge Graph**:\n   ```\n   After 100 notes, Alex: \"Build knowledge graph\"\n   Zapomni: Connects Transformer → BERT → GPT → Claude (all use self-attention)\n   Result: Visual map of AI concepts\n   ```\n\n3. **Retrieval**:\n   ```\n   Alex (3 months later): \"What did I learn about attention mechanisms?\"\n   Zapomni: Finds all notes mentioning attention, shows relationships\n   Returns: Original notes + context from graph\n   ```\n\n**Value Delivered**:\n- Never forget learned concepts\n- Discover connections between ideas\n- Personal knowledge compounds over time\n- Privacy: Personal notes never uploaded\n\n**Acceptance Criteria**:\n- [x] Easy note-taking (natural language)\n- [x] Knowledge graph visualizes connections\n- [x] Fast retrieval (< 1 second)\n- [x] 100% private and local\n\n---\n\n### User Story 4: Legal Document Analysis\n\n**Persona**: Maria, Legal Researcher\n\n**Scenario**:\nMaria analyzes contracts and case law. Needs to:\n- Search across 1000+ legal documents\n- Find precedents and citations\n- Comply with attorney-client privilege (no cloud)\n\n**Workflow**:\n1. **Document Upload**:\n   ```\n   Maria: Upload 1000 legal PDFs\n   Zapomni: Processes, preserves structure (sections, clauses), indexes\n   ```\n\n2. **Compliance Search**:\n   ```\n   Maria: \"Find all contracts with indemnification clauses\"\n   Zapomni: Hybrid search → Returns relevant contracts, highlights clauses\n   ```\n\n3. **Relationship Discovery**:\n   ```\n   Maria: \"What cases cite Smith v. Jones?\"\n   Zapomni (with graph): Traverses citation graph → Returns all citing cases\n   ```\n\n**Value Delivered**:\n- Attorney-client privilege maintained (local processing)\n- Fast contract review (saves hours)\n- Citation network discovery\n- Zero legal risk from cloud leaks\n\n**Acceptance Criteria**:\n- [x] Handles 1000+ documents\n- [x] Search respects legal formatting\n- [x] Citation graph accurate\n- [x] Provable local-only operation\n\n---\n\n## Document Status\n\n**Version**: 1.0 (Draft)\n**Created**: 2025-11-22\n**Last Updated**: 2025-11-22\n**Authors**: Tony + Claude Code\n**Reviewers**: Pending\n**Status**: Ready for Review\n\n**Next Steps**:\n1. Review by Tony\n2. Approval via steering workflow\n3. Use as foundation for tech.md and structure.md\n4. Begin Phase 1 implementation\n\n---\n\n**Document Length**: ~800 lines\n**Estimated Reading Time**: 30-40 minutes\n**Target Audience**: Project stakeholders, contributors, potential users\n",
  "fileStats": {
    "size": 59973,
    "lines": 1940,
    "lastModified": "2025-11-22T20:26:39.453Z"
  },
  "comments": []
}